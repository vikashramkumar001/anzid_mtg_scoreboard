<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Master Control</title>
    <!-- Bootstrap 5 CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- Optional Bootstrap 5 JS with Popper.js -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>

    <link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&display=swap" rel="stylesheet">
    <style>
        * {
            font-family: "Bebas Neue", sans-serif; /* BebasNeueBold */
        }

        #successMessage {
            color: green;
            display: none; /* Initially hidden */
        }

        #currentHeaderImage {
            width: 300px; /* Set the width for the current image display */
            margin-top: 20px;
            border: 1px solid #ddd;
        }

        #uploadImagePreview {
            display: none;
        }

        #imagePreview {
            width: 300px; /* Set the width of the preview */
            border: 1px solid #ddd;
        }

        #cancelButton {
            display: none; /* Initially hidden */
        }

        #currentFooterImage {
            width: 300px;
            margin-top: 20px;
            border: 1px solid #ddd;
        }

        #uploadFooterImagePreview {
            display: none;
        }

        #footerImagePreview {
            width: 300px;
            border: 1px solid #ddd;
        }

        #cancelFooterButton {
            display: none;
        }

        .custom-dropdown {
            position: relative;
            display: inline-block;
            width: 100%;
        }

        .custom-dropdown input {
            width: 100%;
            padding: 5px;
        }

        .custom-dropdown .dropdown-list {
            position: absolute;
            width: 100%;
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #ccc;
            background-color: white;
            display: none;
            z-index: 1000;
        }

        .custom-dropdown .dropdown-item {
            padding: 5px;
            cursor: pointer;
        }

        .custom-dropdown .dropdown-item:hover {
            background-color: #f0f0f0;
        }

        .deck-item {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }

        .deck-image-preview {
            width: 50px;
            height: 50px;
            object-fit: cover;
            margin-right: 10px;
        }

        .deck-name {
            flex-grow: 1;
            margin-right: 10px;
        }

        .deck-actions {
            display: flex;
            gap: 5px;
        }
    </style>
    <script src="/socket.io/socket.io.js"></script>
</head>
<body class="container mt-5">
<div class="container mt-5">
    <div class="row">
        <div class="col-12">
            <h1 class="mb-4">Master Control</h1>
        </div>
        <div class="col-12">
            <h2>Overlay Control</h2>
        </div>
    </div>
    <div class="row mt-5">
        <div class="col-4">
            <!-- Current Image Display -->
            <h3>Current Header Overlay:</h3>
            <img id="currentHeaderImage" alt="Currently Set Header Image" class="img-fluid mb-4" src=""/>
        </div>
        <div class="col-4">
            <!-- Upload Header Image Form -->
            <h3>Upload New Header Overlay:</h3>
            <form id="uploadForm" enctype="multipart/form-data" class="mb-4">
                <div class="mb-3">
                    <label for="overlayImage" class="form-label">Upload 1920x100 Header Overlay Image:</label>
                    <input type="file" id="overlayImage" name="overlay" class="form-control" accept="image/*" required>
                </div>
                <button type="submit" class="btn btn-primary">Upload</button>
                <button type="button" id="cancelButton" class="btn btn-secondary">Cancel Upload</button>
            </form>
        </div>
        <div class="col-4">
            <div id="uploadImagePreview" class="mb-4">
                <h3>Upload Preview:</h3>
                <!-- Image Preview -->
                <img id="imagePreview" alt="Image Preview" class="img-fluid" src="">
            </div>

            <!-- Success Message Display -->
            <p id="successMessage" class="alert alert-success"></p>
        </div>
    </div>
    <div class="row mt-5">
        <div class="col-4">
            <!-- Current Footer Image Display -->
            <h3>Current Footer Overlay:</h3>
            <img id="currentFooterImage" alt="Currently Set Footer Image" class="img-fluid mb-4" src=""/>
        </div>
        <div class="col-4">
            <!-- Upload Footer Image Form -->
            <h3>Upload New Footer Overlay:</h3>
            <form id="uploadFooterForm" enctype="multipart/form-data" class="mb-4">
                <div class="mb-3">
                    <label for="overlayFooterImage" class="form-label">Upload 1920x50 Footer Overlay Image:</label>
                    <input type="file" id="overlayFooterImage" name="overlay_footer" class="form-control" accept="image/*" required>
                </div>
                <button type="submit" class="btn btn-primary">Upload</button>
                <button type="button" id="cancelFooterButton" class="btn btn-secondary">Cancel Upload</button>
            </form>
        </div>
        <div class="col-4">
            <div id="uploadFooterImagePreview" class="mb-4">
                <h3>Upload Preview:</h3>
                <!-- Footer Image Preview -->
                <img id="footerImagePreview" alt="Footer Image Preview" class="img-fluid" src="">
            </div>

            <!-- Footer Success Message Display -->
            <p id="footerSuccessMessage" class="alert alert-success" style="display: none;"></p>
        </div>
    </div>
    <div class="row">
        <div class="col-12">
            <h2>Match Control Center</h2>
        </div>
        <div id="matchControlCenter">
        </div>
    </div>
    <div class="row my-5">
        <div class="col-12">
            <h2>Deck List Management</h2>
        </div>
        <div class="col-6">
            <h3>Current Deck List</h3>
            <ul id="deckList" class="list-group">
                <!-- Deck list items will be dynamically added here -->
            </ul>
        </div>
        <div class="col-6">
            <h3>Add New Deck(s)</h3>
            <form id="addDeckForm" class="mb-3">
                <div class="form-group">
                    <textarea id="newDeckInput" class="form-control" rows="4" 
                              placeholder="Enter deck name(s) - separate multiple decks with commas or new lines" required></textarea>
                </div>
                <button class="btn btn-primary mt-2" type="submit">Add Deck(s)</button>
            </form>
        </div>
    </div>
</div>

<template id="custom-dropdown-template">
    <div class="custom-dropdown">
        <input type="text" class="form-control">
        <div class="dropdown-list"></div>
    </div>
</template>

<script>
    const socket = io();
    const currentHeaderImage = document.getElementById('currentHeaderImage');
    const preview = document.getElementById('imagePreview'); // Get the preview element
    const previewContainer = document.getElementById('uploadImagePreview'); // Get the preview element
    const successMessage = document.getElementById('successMessage');
    const cancelButton = document.getElementById('cancelButton');
    const overlayHeaderImage = document.getElementById('overlayImage');
    const matchContainer = document.getElementById('matchControlCenter');
    let allControlData = {};

    // Handle the form submission via JavaScript (AJAX)
    const form = document.getElementById('uploadForm');
    form.addEventListener('submit', function (event) {
        event.preventDefault(); // Prevent the form from submitting the traditional way

        // Create a FormData object to hold the file input data
        const formData = new FormData();
        formData.append('overlay_header', overlayHeaderImage.files[0]);

        // Submit the form via fetch (AJAX)
        fetch('/upload-header-overlay', {
            method: 'POST',
            body: formData
        })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    console.log('Image uploaded successfully!');
                    successMessage.textContent = 'Image uploaded successfully';
                    successMessage.style.display = 'block'; // Display the success message

                    // Update the currently set image
                    const cacheBuster = new Date().getTime(); // Get the current timestamp
                    currentHeaderImage.src = data.newImageUrl + '?v=' + cacheBuster; // Set the src to the new image URL
                    currentHeaderImage.style.display = 'block'; // Display the image

                    // stop showing preview container
                    previewContainer.style.display = 'none';

                    // stop showing cancel button
                    cancelButton.style.display = 'none';

                    // Clear the file input
                    overlayImage.value = '';
                } else {
                    console.error('Upload failed');
                }
            })
            .catch(error => {
                console.error('Error uploading image:', error);
            });
    });

    // Image preview functionality
    overlayHeaderImage.addEventListener('change', function (event) {
        const file = event.target.files[0]; // Get the selected file
        const reader = new FileReader();

        if (file) {
            reader.readAsDataURL(file); // Read the file as a data URL (base64)

            reader.onload = function (e) {
                // show cancel button
                cancelButton.style.display = 'inline';
                // remove message if exists
                successMessage.style.display = 'none';
                // Set the src of the preview image
                preview.src = e.target.result;
                // Display the preview image
                previewContainer.style.display = 'block';
            };
        }
    });

    // Cancel upload functionality
    cancelButton.addEventListener('click', function () {
        // Clear the file input
        overlayImage.value = '';
        // Hide the preview image and cancel button
        previewContainer.style.display = 'none';
        cancelButton.style.display = 'none';
    });

    // Function to render or update a match card
    function renderMatch(matchId, matchData) {
        // Check if a card for this match already exists
        let matchCard = document.getElementById(`match-card-${matchId}`);
        if (!matchCard) {
            // If not, create a new card
            matchCard = document.createElement('div');
            matchCard.classList.add('col-12', 'mb-3', 'match-card-container');
            matchCard.id = `match-card-${matchId}`;
            matchCard.innerHTML = `
            <h3 class="match-id-name">${matchId}</h3>
            <div class="card">
                <div class="card-body">
                    <div class="row">
                        <!-- Event Information -->
                        <div class="col-md-4">
                            <h5 class="card-title">Event Information</h5>
                            <div class="mb-3">
                                <label class="form-label">Event Name</label>
                                <div id="${matchId}-event-name" class="editable form-control" contenteditable="true"></div>
                            </div>
                            <div class="mb-3">
                                <label class="form-label">Event Round</label>
                                <div id="${matchId}-event-round" class="editable form-control" contenteditable="true"></div>
                            </div>
                            <div class="mb-3">
                                <label class="form-label">Event Format</label>
                                <div id="${matchId}-event-format" class="editable form-control" contenteditable="true"></div>
                            </div>
                        </div>

                        <!-- Left Player Information -->
                        <div class="col-md-4">
                            <h5 class="card-title">Left Player</h5>
                            <div class="mb-3">
                                <label class="form-label">Player Name</label>
                                <div id="${matchId}-player-name-left" class="editable form-control" contenteditable="true"></div>
                            </div>
                            <div class="mb-3">
                                <label class="form-label">LifePoints</label>
                                <div id="${matchId}-player-life-left" class="editable form-control" contenteditable="true"></div>
                            </div>
                            <div class="mb-3">
                                <label class="form-label">Pronouns</label>
                                <div id="${matchId}-player-pronouns-left" class="editable form-control" contenteditable="true"></div>
                            </div>
                            <div class="mb-3">
                                <label class="form-label">Archetype</label>
                                <div id="${matchId}-player-archetype-left" class="editable form-control" contenteditable="true"></div>
                            </div>
                            <div class="mb-3">
                                <label class="form-label">Record</label>
                                <div id="${matchId}-player-record-left" class="editable form-control" contenteditable="true"></div>
                            </div>
                            <div class="mb-3">
                                <label class="form-label">Wins</label>
                                <div id="${matchId}-player-wins-left" class="editable form-control" contenteditable="true"></div>
                            </div>
                            <div class="mb-3">
                                <label class="form-label">Poison</label>
                                <div id="${matchId}-player-poison-left" class="editable form-control" contenteditable="true"></div>
                            </div>
                        </div>

                        <!-- Right Player Information -->
                        <div class="col-md-4">
                            <h5 class="card-title">Right Player</h5>
                            <div class="mb-3">
                                <label class="form-label">Player Name</label>
                                <div id="${matchId}-player-name-right" class="editable form-control" contenteditable="true"></div>
                            </div>
                            <div class="mb-3">
                                <label class="form-label">LifePoints</label>
                                <div id="${matchId}-player-life-right" class="editable form-control" contenteditable="true"></div>
                            </div>
                            <div class="mb-3">
                                <label class="form-label">Pronouns</label>
                                <div id="${matchId}-player-pronouns-right" class="editable form-control" contenteditable="true"></div>
                            </div>
                            <div class="mb-3">
                                <label class="form-label">Archetype</label>
                                <div id="${matchId}-player-archetype-right" class="editable form-control" contenteditable="true"></div>
                            </div>
                            <div class="mb-3">
                                <label class="form-label">Record</label>
                                <div id="${matchId}-player-record-right" class="editable form-control" contenteditable="true"></div>
                            </div>
                            <div class="mb-3">
                                <label class="form-label">Wins</label>
                                <div id="${matchId}-player-wins-right" class="editable form-control" contenteditable="true"></div>
                            </div>
                            <div class="mb-3">
                                <label class="form-label">Poison</label>
                                <div id="${matchId}-player-poison-right" class="editable form-control" contenteditable="true"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        `;
            // Add the new card to the container
            matchContainer.appendChild(matchCard);
            // Attach change listeners to all editable fields within this match card
            attachChangeListeners(matchId);
        }
        // Update the fields with the match data
        Object.keys(matchData).forEach(key => {
            const fieldElement = document.getElementById(`${matchId}-${key}`);
            if (fieldElement) {
                fieldElement.textContent = matchData[key];
            }
        });
    }

    // Function to attach change listeners to all editable fields for a given match ID
    function attachChangeListeners(matchId) {
        const editableFields = document.querySelectorAll(`#match-card-${matchId} .editable`);
        editableFields.forEach(field => {
            field.addEventListener('input', () => {
                // Update the local control data when a field changes
                updateControlData(matchId, field.id.replace(`${matchId}-`, ''), field.textContent);
                // Emit the updated control data to the backend
                console.log('updated all data', allControlData);
                socket.emit('master-control-matches-updated', allControlData);
            });
        });
    }

    // Function to update the control data for a specific match
    function updateControlData(matchId, key, value) {
        if (!allControlData[matchId]) {
            allControlData[matchId] = {};
        }
        allControlData[matchId][key] = value;
    }

    // Function to remove match cards that no longer exist
    function removeStaleMatches(activeMatchIds) {
        // Get all existing match cards in the DOM
        const matchCards = matchContainer.querySelectorAll('.match-card-container');
        console.log(matchCards)
        matchCards.forEach(card => {
            const matchId = card.id.replace('match-card-', '');
            // If the matchId is not in the activeMatchIds, remove the card
            if (!activeMatchIds.has(matchId)) {
                card.remove();
                console.log(`Removed match card for matchId: ${matchId}`);
            }
        });
    }

    // Listen for background image update
    socket.on('overlayHeaderBackgroundUpdate', (newImageUrl) => {
        console.log('Overlay header background image:', newImageUrl);

        // Update the currently set image
        currentHeaderImage.src = newImageUrl; // Set the src to the new image URL
        currentHeaderImage.style.display = 'block'; // Display the image
    });

    // Listen for background image update
    socket.on('overlayHeaderBackgroundUpdate', (newImageUrl) => {
        console.log('Overlay header background image:', newImageUrl);

        // Update the currently set image
        currentHeaderImage.src = newImageUrl; // Set the src to the new image URL
        currentHeaderImage.style.display = 'block'; // Display the image
    });

    // Listen for any updates to full control data to update the page
    socket.on('control-data-updated', (allData) => {
        console.log('Control data was updated', allData);
        // save to local object
        allControlData = allData;
        // Get the current active match IDs from the incoming data
        const activeMatchIds = new Set(Object.keys(allControlData));

        // Render or update each match card
        Object.entries(allControlData).forEach(([matchId, matchData]) => {
            renderMatch(matchId, matchData);
        });

        // Remove any match cards that are no longer active
        removeStaleMatches(activeMatchIds);

        // After creating all the inputs, set up the custom dropdowns
        setupCustomDropdowns();
    });

    const currentFooterImage = document.getElementById('currentFooterImage');
    const footerPreview = document.getElementById('footerImagePreview');
    const footerPreviewContainer = document.getElementById('uploadFooterImagePreview');
    const footerSuccessMessage = document.getElementById('footerSuccessMessage');
    const cancelFooterButton = document.getElementById('cancelFooterButton');
    const overlayFooterImage = document.getElementById('overlayFooterImage');

    // Handle the footer form submission
    const footerForm = document.getElementById('uploadFooterForm');
    footerForm.addEventListener('submit', function (event) {
        event.preventDefault();

        const formData = new FormData();
        formData.append('overlay_footer', overlayFooterImage.files[0]);

        fetch('/upload-footer-overlay', {
            method: 'POST',
            body: formData
        })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    console.log('Footer image uploaded successfully!');
                    footerSuccessMessage.textContent = 'Footer image uploaded successfully';
                    footerSuccessMessage.style.display = 'block';

                    const cacheBuster = new Date().getTime();
                    currentFooterImage.src = data.newImageUrl + '?v=' + cacheBuster;
                    currentFooterImage.style.display = 'block';

                    footerPreviewContainer.style.display = 'none';
                    cancelFooterButton.style.display = 'none';
                    overlayFooterImage.value = '';
                } else {
                    console.error('Footer upload failed');
                }
            })
            .catch(error => {
                console.error('Error uploading footer image:', error);
            });
    });

    // Footer image preview functionality
    overlayFooterImage.addEventListener('change', function (event) {
        const file = event.target.files[0];
        const reader = new FileReader();

        if (file) {
            reader.readAsDataURL(file);

            reader.onload = function (e) {
                cancelFooterButton.style.display = 'inline';
                footerSuccessMessage.style.display = 'none';
                footerPreview.src = e.target.result;
                footerPreviewContainer.style.display = 'block';
            };
        }
    });

    // Cancel footer upload functionality
    cancelFooterButton.addEventListener('click', function () {
        overlayFooterImage.value = '';
        footerPreviewContainer.style.display = 'none';
        cancelFooterButton.style.display = 'none';
    });

    // Listen for footer background image update
    socket.on('overlayFooterBackgroundUpdate', (newImageUrl) => {
        console.log('Overlay footer background image:', newImageUrl);
        currentFooterImage.src = newImageUrl;
        currentFooterImage.style.display = 'block';
    });

    // Deck list management
    const deckList = document.getElementById('deckList');
    const addDeckForm = document.getElementById('addDeckForm');
    const newDeckInput = document.getElementById('newDeckInput');

    // Function to render the deck list
    function renderDeckList(decks) {
        deckList.innerHTML = '';
        decks.forEach(deck => {
            const li = document.createElement('li');
            li.className = 'list-group-item deck-item';
            
            if (deck.imageUrl) {
                const img = document.createElement('img');
                const cacheBuster = new Date().getTime();
                img.className = 'deck-image-preview';
                img.src = deck.imageUrl + '?v=' + cacheBuster;
                img.alt = deck.name;
                li.appendChild(img);
            }
            
            const nameSpan = document.createElement('span');
            nameSpan.className = 'deck-name';
            nameSpan.textContent = deck.name;
            
            const actionsDiv = document.createElement('div');
            actionsDiv.className = 'deck-actions';
            
            const uploadLabel = document.createElement('label');
            uploadLabel.className = 'btn btn-secondary btn-sm';
            uploadLabel.textContent = deck.imageUrl ? 'Change Image' : 'Upload Image';
            
            const uploadInput = document.createElement('input');
            uploadInput.type = 'file';
            uploadInput.accept = 'image/*';
            uploadInput.style.display = 'none';
            uploadInput.addEventListener('change', (e) => uploadDeckImage(deck.name, e.target.files[0]));
            
            uploadLabel.appendChild(uploadInput);
            
            const deleteButton = document.createElement('button');
            deleteButton.className = 'btn btn-danger btn-sm';
            deleteButton.textContent = 'Delete';
            deleteButton.onclick = () => deleteDeck(deck.name);
            
            actionsDiv.appendChild(uploadLabel);
            actionsDiv.appendChild(deleteButton);
            
            li.appendChild(nameSpan);
            li.appendChild(actionsDiv);
            
            deckList.appendChild(li);
        });
    }

    function uploadDeckImage(deckName, file) {
        const formData = new FormData();
        formData.append('deckName', deckName);
        formData.append('image', file);

        fetch('/upload-deck-image', {
            method: 'POST',
            body: formData
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                console.log('Image uploaded successfully');
                socket.emit('getDeckList');
            } else {
                console.error('Failed to upload image:', data.message);
                alert('Failed to upload image: ' + data.message);
            }
        })
        .catch(error => {
            console.error('Error uploading image:', error);
            alert('Error uploading image. Please try again.');
        });
    }

    // Function to add a new deck
    function addDeck(deckName) {
        socket.emit('addDeck', deckName);
    }

    // Function to delete a deck
    function deleteDeck(deckName) {
        socket.emit('deleteDeck', deckName);
    }

    // Function to add new decks
    function addDecks(deckNames) {
        // Filter out any deck names that already exist in the current list
        const newDeckNames = deckNames.filter(name => !currentDeckList.includes(name));
        if (newDeckNames.length > 0) {
            socket.emit('addDecks', newDeckNames);
        }
    }

    let currentDeckList = []; // Keep track of the current deck list

    // Handle form submission for adding new decks
    addDeckForm.addEventListener('submit', (e) => {
        e.preventDefault();
        const input = newDeckInput.value.trim();
        if (input) {
            // Split input by commas or newlines, then trim each entry and filter out empty strings and duplicates
            const deckNames = [...new Set(input.split(/[,\n]+/).map(name => name.trim()).filter(name => name !== ''))];
            addDecks(deckNames);
            newDeckInput.value = '';
        }
    });

    // Listen for updated deck list from server
    socket.on('deckListUpdated', (decks) => {
        currentDeckList = decks; // Update the current deck list
        renderDeckList(decks);
    });

    // Request initial deck list when page loads
    socket.emit('getDeckList');

    // Function to initialize the deck list
    function initializeDeckList() {
        socket.emit('getDeckList');
    }

    // Listen for updated deck list from server
    socket.on('deckListUpdated', (decks) => {
        currentDeckList = decks; // Update the current deck list
        renderDeckList(decks);
    });

    // Initialize the deck list when the page loads
    initializeDeckList();

    function renderDropdownList(dropdownList, items, field) {
        dropdownList.innerHTML = '';
        items.forEach(item => {
            const div = document.createElement('div');
            div.textContent = item.name;
            div.classList.add('dropdown-item');
            div.addEventListener('click', function() {
                field.textContent = item.name;
                dropdownList.style.display = 'none';
                field.dispatchEvent(new Event('input'));
                field.dispatchEvent(new Event('change')); // Trigger change event
            });
            dropdownList.appendChild(div);
        });
        dropdownList.style.display = items.length > 0 ? 'block' : 'none';
    }

    function setupCustomDropdowns() {
        const archetypeFields = document.querySelectorAll('[id$="-player-archetype-left"], [id$="-player-archetype-right"]');
        
        archetypeFields.forEach(field => {
            if (field.parentNode.classList.contains('custom-dropdown')) {
                return; // Skip if already set up
            }

            const wrapper = document.createElement('div');
            wrapper.className = 'custom-dropdown';
            field.parentNode.insertBefore(wrapper, field);
            wrapper.appendChild(field);

            const dropdownList = document.createElement('div');
            dropdownList.className = 'dropdown-list';
            wrapper.appendChild(dropdownList);

            field.addEventListener('input', function() {
                const value = this.textContent.trim().toLowerCase();
                const filteredDecks = currentDeckList.filter(deck => 
                    deck.name.toLowerCase().includes(value)
                );
                renderDropdownList(dropdownList, filteredDecks, field);
            });

            field.addEventListener('focus', function() {
                renderDropdownList(dropdownList, currentDeckList, field);
            });

            document.addEventListener('click', function(e) {
                if (!wrapper.contains(e.target)) {
                    dropdownList.style.display = 'none';
                }
            });
        });
    }

    // Initial setup when the page loads
    document.addEventListener('DOMContentLoaded', () => {
        setupCustomDropdowns();
    });
</script>
</body>
</html>
